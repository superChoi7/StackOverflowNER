https://leetcode.com/problems/meeting-rooms-ii/discuss/67855/Explanation-of-%22Super-Easy-Java-Solution-Beats-98.8%22-from-%40pinkfloyda
Explanation of \"Super Easy Java Solution Beats 98.8%\" from @pinkfloyda
The solution is proposed by @pinkfloyda at [\"Super Easy Java Solution Beats 98.8%\"][1] , which is amazing.  Here I would like to explain why it works a little bit.  The code from @pinkfloyda:  ```    public class Solution {         public int minMeetingRooms(Interval[] intervals) {             int[] starts = new int[intervals.length];             int[] ends = new int[intervals.length];             for(int i=0; i<intervals.length; i++) {                 starts[i] = intervals[i].start;                 ends[i] = intervals[i].end;             }             Arrays.sort(starts);             Arrays.sort(ends);             int rooms = 0;             int endsItr = 0;             for(int i=0; i<starts.length; i++) {                 if(starts[i]<ends[endsItr])                     rooms++;                 else                     endsItr++;             }             return rooms;         }     }```  To understand why it works, first let\’s define two events: Meeting Starts Meeting Ends  Next, we acknowledge three facts: The numbers of the intervals give chronological orders When an ending event occurs, there must be a starting event has happened before that, where \“happen before\” is defined by the chronological orders given by the intervals Meetings that started which haven\’t ended yet have to be put into different meeting rooms, and the number of rooms needed is the number of such meetings  So, what this algorithm works as follows:  for example, we have meetings that span along time as follows:      |_____|           |______|     |________|             |_______|  Then, the start time array and end time array after sorting appear like follows:      ||    ||          |   |   |  |  Initially, `endsItr` points to the first end event, and we move `i` which is the start event pointer. As we examine the start events, we\’ll find the first two start events happen before the end event that `endsItr` points to, so we need two rooms (we magically created two rooms), as shown by the variable rooms. Then, as `i` points to the third start event, we\’ll find that this event happens after the end event pointed by `endsItr`, then we increment `endsItr` so that it points to the next end event. What happens here can be thought of as one of the two previous meetings ended, and we moved the newly started meeting into that vacant room, thus we don\’t need to increment rooms at this time and move both of the pointers forward. Next, because `endsItr` moves to the next end event, we\’ll find that the start event pointed by `i` happens before the end event pointed by `endsItr`. Thus, now we have 4 meetings started but only one ended, so we need one more room. And it goes on as this.     [1]: https://leetcode.com/discuss/71846/super-easy-java-solution-beats-98-8%25

https://leetcode.com/problems/meeting-rooms-ii/discuss/67857/AC-Java-solution-using-min-heap
AC Java solution using min heap
Just want to share another idea that uses min heap, average time complexity is O(nlogn).      public int minMeetingRooms(Interval[] intervals) {         if (intervals == null || intervals.length == 0)             return 0;                      // Sort the intervals by start time         Arrays.sort(intervals, new Comparator<Interval>() {             public int compare(Interval a, Interval b) { return a.start - b.start; }         });                  // Use a min heap to track the minimum end time of merged intervals         PriorityQueue<Interval> heap = new PriorityQueue<Interval>(intervals.length, new Comparator<Interval>() {             public int compare(Interval a, Interval b) { return a.end - b.end; }         });                  // start with the first meeting, put it to a meeting room         heap.offer(intervals[0]);                  for (int i = 1; i < intervals.length; i++) {             // get the meeting room that finishes earliest             Interval interval = heap.poll();                          if (intervals[i].start >= interval.end) {                 // if the current meeting starts right after                  // there's no need for a new room, merge the interval                 interval.end = intervals[i].end;             } else {                 // otherwise, this meeting needs a new room                 heap.offer(intervals[i]);             }                          // don't forget to put the meeting room back             heap.offer(interval);         }                  return heap.size();     }

https://leetcode.com/problems/integer-to-english-words/discuss/70625/My-clean-Java-solution-very-easy-to-understand
My clean Java solution, very easy to understand
```    private final String[] LESS_THAN_20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}; \\tprivate final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"}; \\tprivate final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"}; \\t     public String numberToWords(int num) {         if (num == 0) return \"Zero\";          int i = 0;         String words = \"\";                  while (num > 0) {             if (num % 1000 != 0)         \\t    words = helper(num % 1000) +THOUSANDS[i] + \" \" + words;         \\tnum /= 1000;         \\ti++;         }                  return words.trim();     }          private String helper(int num) {         if (num == 0)             return \"\";         else if (num < 20)             return LESS_THAN_20[num] + \" \";         else if (num < 100)             return TENS[num / 10] + \" \" + helper(num % 10);         else             return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);     }```

https://leetcode.com/problems/alien-dictionary/discuss/70119/Java-AC-solution-using-BFS
Java AC solution using BFS
```    public String alienOrder(String[] words) {         Map<Character, Set<Character>> map=new HashMap<Character, Set<Character>>();         Map<Character, Integer> degree=new HashMap<Character, Integer>();         String result=\"\";         if(words==null || words.length==0) return result;         for(String s: words){             for(char c: s.toCharArray()){                 degree.put(c,0);             }         }         for(int i=0; i<words.length-1; i++){             String cur=words[i];             String next=words[i+1];             int length=Math.min(cur.length(), next.length());             for(int j=0; j<length; j++){                 char c1=cur.charAt(j);                 char c2=next.charAt(j);                 if(c1!=c2){                     Set<Character> set=new HashSet<Character>();                     if(map.containsKey(c1)) set=map.get(c1);                     if(!set.contains(c2)){                         set.add(c2);                         map.put(c1, set);                         degree.put(c2, degree.get(c2)+1);                     }                     break;                 }             }         }         Queue<Character> q=new LinkedList<Character>();         for(char c: degree.keySet()){             if(degree.get(c)==0) q.add(c);         }         while(!q.isEmpty()){             char c=q.remove();             result+=c;             if(map.containsKey(c)){                 for(char c2: map.get(c)){                     degree.put(c2,degree.get(c2)-1);                     if(degree.get(c2)==0) q.add(c2);                 }             }         }         if(result.length()!=degree.size()) return \"\";         return result;     }```

https://leetcode.com/problems/trapping-rain-water/discuss/17357/Sharing-my-simple-c%2B%2B-code%3A-O(n)-time-O(1)-space
Sharing my simple c++ code: O(n) time, O(1) space
     Here is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1).  Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of  partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container.  ```    class Solution {     public:         int trap(int A[], int n) {             int left=0; int right=n-1;             int res=0;             int maxleft=0, maxright=0;             while(left<=right){                 if(A[left]<=A[right]){                     if(A[left]>=maxleft) maxleft=A[left];                     else res+=maxleft-A[left];                     left++;                 }                 else{                     if(A[right]>=maxright) maxright= A[right];                     else res+=maxright-A[right];                     right--;                 }             }             return res;         }     };```

https://leetcode.com/problems/regular-expression-matching/discuss/5651/Easy-DP-Java-Solution-with-detailed-Explanation
Easy DP Java Solution with detailed Explanation
This Solution use 2D DP. beat 90% solutions, very simple.  Here are some conditions to figure out, then the logic can be very straightforward.      1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];     2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];     3, If p.charAt(j) == '*':         here are two sub conditions:                    1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty                    2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':                                   dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a                                 or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a                                or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty  Here is the solution      public boolean isMatch(String s, String p) {          if (s == null || p == null) {             return false;         }         boolean[][] dp = new boolean[s.length()+1][p.length()+1];         dp[0][0] = true;         for (int i = 0; i < p.length(); i++) {             if (p.charAt(i) == '*' && dp[0][i-1]) {                 dp[0][i+1] = true;             }         }         for (int i = 0 ; i < s.length(); i++) {             for (int j = 0; j < p.length(); j++) {                 if (p.charAt(j) == '.') {                     dp[i+1][j+1] = dp[i][j];                 }                 if (p.charAt(j) == s.charAt(i)) {                     dp[i+1][j+1] = dp[i][j];                 }                 if (p.charAt(j) == '*') {                     if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {                         dp[i+1][j+1] = dp[i+1][j-1];                     } else {                         dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);                     }                 }             }         }         return dp[s.length()][p.length()];     }

https://leetcode.com/problems/guess-the-word/discuss/133862/Random-Guess-and-Minimax-Guess-with-Comparison
Random Guess and Minimax Guess with Comparison
# **Discuss**: Random Guess and Minimax Guess with Comparison  # Foreword Great! Finally we have an interactive problem on LeetCode platform.  The description emphasizes that, the wordlist is generated randomly and it\\'s does have a reason.  There is no solution that can guarantee to find a secret word in 10 tries. If I make up a test case with wordlist like `[\"aaaaaa\", \"bbbbbb\" ...., \"zzzzzz\"]`, it needs 26 tries to find the secret.  So 10 tries is just a constrain to check a reasonable solution. And instead of just finding right output from given input, it\\'s more about a strategy.  **So it doesn\\'t make any sense to do any hand-made \"extra challendge\".** <br><br>   # Intuition Take a word from wordlist and guess it. Get the matches of this word Update our wordlist and keep only the same matches to our guess.  This process is straight forward. However, the key point is, which word should we guess from all of the wordlist? <br><br>   # Prepare For example we guess \"aaaaaa\" and get matches `x = 3`, we keep the words with exactly 3 `a` .  Also we need to know the matches between two words, so a helper function `match` as following will be useful.  **C++:** ```cpp     int match(string a, string b) {         int matches = 0;         for (int i = 0; i < a.length(); ++i)             if (a[i] == b[i])                 matches ++;         return matches;     } ```  **Java:** ```java     public int match(String a, String b) {         int matches = 0;         for (int i = 0; i < a.length(); ++i)             if (a.charAt(i) == b.charAt(i))                 matches ++;         return matches;     } ```  **Python** ```py     def match(self, w1, w2):         return sum(i == j for i, j in zip(w1, w2)) ``` <br><br>      # Solution 1: Always Guess the First One First of all, we just guessed the first word in the wordlist. Unfortunately, it didn\\'t get a lucky pass. This problem has only 5 test cases but they are good.  Time complexity `O(N)` Space complexity `O(N)` <br><br>  # Solution 2.1: Shuffle the Wordlist I didn\\'t give up the previous idea, it\\'s not that bad. So I decided to try my luck by shuffling `wordlist` at the beginning.  Note that it may sound some unreliable, but actully randomicity is very useful trick in both competition and reality problem.   This method can get accepted but not for sure. After manualy testing locally, on Leetcode\\'s test cases set and random test cases set, it has roughly 70% rate to get accepted.  However, C++ may set random seed in the OJ. I keep submitting but doesn\\'t fail.  Time complexity `O(N)` Space complexity `O(N)` <br>  **C++** ```cpp     void findSecretWord(vector<string>& wordlist, Master& master) {         random_shuffle(wordlist.begin(), wordlist.end());         for (int i = 0, x = 0; i < 10 && x < 6; ++i) {             string guess = wordlist[0];             x = master.guess(guess);             vector<string> wordlist2;             for (string w : wordlist)                 if (match(guess, w) == x)                     wordlist2.push_back(w);             wordlist = wordlist2;         }     } ```  **Python:** ```py     def findSecretWord(self, wordlist, master):         random.shuffle(wordlist)         for i in range(10):             guess = random.choice(0)             x = master.guess(guess)             wordlist = [w for w in wordlist if sum(i == j for i, j in zip(guess, w)) == x] ``` <br><br>    # Solution 2.2: Guess a Random Word All words are generated randomly. So why not we also guess a random word and let it be whatever will be. This is actually the same as the previous solution. Though we don\\'t need one more `O(N)` operation to shuffle the `wordlist` at first.  Time complexity `O(N)` Space complexity `O(N)`  **C++:** ```cpp     void findSecretWord(vector<string>& wordlist, Master& master) {         for (int i = 0, x = 0; i < 10 && x < 6; ++i) {             string guess = wordlist[rand() % (wordlist.size())];             x = master.guess(guess);             vector<string> wordlist2;             for (string w : wordlist)                 if (match(guess, w) == x)                     wordlist2.push_back(w);             wordlist = wordlist2;         }     } ```  **Java:** ```java     public void findSecretWord(String[] wordlist, Master master) {         for (int i = 0, x = 0; i < 10 && x < 6; ++i) {             String guess = wordlist[new Random().nextInt(wordlist.length)];             x = master.guess(guess);             List<String> wordlist2 = new ArrayList<>();             for (String w : wordlist)                 if (match(guess, w) == x)                     wordlist2.add(w);             wordlist = wordlist2.toArray(new String[wordlist2.size()]);         }     } ``` **Python:** ```py     def findSecretWord(self, wordlist, master):         for i in range(10):             guess = random.choice(wordlist)             x = master.guess(guess)             wordlist = [w for w in wordlist if sum(i == j for i, j in zip(guess, w)) == x] ``` <br><br>   # Solution 3: Minimax  Now we want to try a better solution. Generally, we will get 0 matches from the `master.guess`. As a result, the size of `wordlist` reduces slowly.  Recall some math here, the possiblity that get 0 matched is: (25/26) ^ 6 = 79.03%  That is to say, if we make a blind guess, we have about 80% chance to get 0 matched with the secret word.  To simplify the model, we\\'re going to assume that, we will always run into the worst case (get 0 matched).  In this case, we have 80% chance to eliminate the candidate word as well as its close words which have at least 1 match.  Additionally, in order to delete a max part of words, we select a candidate who has a big \"family\", (that is, the fewest 0 matched with other words.) **We want to guess a word that can minimum our worst outcome.**  So we compare each two words and count their matches. For each word, we note how many word of 0 matches it gets. Then we guess the word with minimum words of 0 matches.  In this solution, we apply a minimax idea. We minimize our worst case, The worst case is `max(the number of words with x matches)`, and we assume it equal to \"the number of words with 0 matches\"  Time complexity `O(N^2)` Space complexity `O(N)`  **C++:** ```cpp     void findSecretWord(vector<string>& wordlist, Master& master) {         for (int i = 0, x = 0; i < 10 && x < 6; ++i) {             unordered_map<string, int> count;             for (string w1 : wordlist)                 for (string w2 : wordlist)                     if (match(w1, w2) == 0)                         count[w1]++;             pair<string, int> minimax = {wordlist[0], 1000};             for (string w : wordlist)                 if (count[w] <= minimax.second)                     minimax = make_pair(w, count[w]);             x = master.guess(minimax.first);             vector<string> wordlist2;             for (string w : wordlist)                 if (match(minimax.first, w) == x)                     wordlist2.push_back(w);             wordlist = wordlist2;         }     } ```  **Java:** ```java     public void findSecretWord(String[] wordlist, Master master) {         for (int i = 0, x = 0; i < 10 && x < 6; ++i) {             HashMap<String, Integer> count = new HashMap<>();             for (String w1 : wordlist)                 for (String w2 : wordlist)                     if (match(w1, w2) == 0)                         count.put(w1, count.getOrDefault(w1 , 0) + 1);             String guess = \"\";             int min0 = 100;             for (String w : wordlist)                 if (count.getOrDefault(w, 0) < min0) {                     guess = w;                     min0 = count.getOrDefault(w, 0);                 }             x = master.guess(guess);             List<String> wordlist2 = new ArrayList<String>();             for (String w : wordlist)                 if (match(guess, w) == x)                     wordlist2.add(w);             wordlist = wordlist2.toArray(new String[0]);         }     } ``` **Python:** ```py     def findSecretWord(self, wordlist, master):         x = 0         while x < 6:             count = collections.Counter(w1 for w1, w2 in itertools.permutations(wordlist, 2) if self.match(w1, w2) == 0)             guess = min(wordlist, key=lambda w: count[w])             x = master.guess(guess)             wordlist = [w for w in wordlist if self.match(w, guess) == x] ``` <br><br>  # **Result Analyse** To be more convincing, I test each approach with 1000 test cases. For the random approach, average 6.5 guess, worst case 14 guess. For the minimax  approach, average 5.5 guess, worst case 10 guess. I draw this diagram to visualize the result: ![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1527391162.png) <br><br>  # Solution 4: Count the Occurrence of Characters In the previous solution, we compaired each two words. This make the complexity `O(N^2)` for each turn.  But actually we don\\'t have to do that. We just need to count the occurrence for each character on each position.  If we can guess the word that not in the wordlist, we can guess the word based on the most frequent character on the position.  Here we have to guess a word from the list, we still can calculate a score of similarity for each word, and guess the word with highest score.  Time complexity `O(N)` Space complexity `O(N)` <br>  **Java** ```java     public void findSecretWord(String[] wordlist, Master master) {         for (int t = 0, x = 0; t < 10 && x < 6; ++t) {             int count[][] = new int[6][26], best = 0;             for (String w : wordlist)                 for (int i = 0; i < 6; ++i)                     count[i][w.charAt(i) - \\'a\\']++;             String guess = wordlist[0];             for (String w: wordlist) {                 int score = 0;                 for (int i = 0; i < 6; ++i)                     score += count[i][w.charAt(i) - \\'a\\'];                 if (score > best) {                     guess = w;                     best = score;                 }             }             x = master.guess(guess);             List<String> wordlist2 = new ArrayList<String>();             for (String w : wordlist)                 if (match(guess, w) == x)                     wordlist2.add(w);             wordlist = wordlist2.toArray(new String[0]);         }     } ``` **C++** ```cpp     void findSecretWord(vector<string>& wordlist, Master& master) {         int count[6][26], x = 0, best;         for (int t = 0; t < 10 && x < 6; ++t) {             memset(count, 0, 156 * sizeof(int));             for (string w : wordlist)                 for (int i = 0; i < 6; ++i)                     count[i][w[i] - \\'a\\']++;             best = 0;             string guess = wordlist[0];             for (string w: wordlist) {                 int score = 0;                 for (int i = 0; i < 6; ++i)                     score += count[i][w[i] - \\'a\\'];                 if (score > best) {                     guess = w;                     best = score;                 }             }             x = master.guess(guess);             vector<string> wordlist2;             for (string w : wordlist)                 if (match(guess, w) == x)                     wordlist2.push_back(w);             wordlist = wordlist2;         }     } ``` **Python** ```py     def findSecretWord(self, wordlist, master):         def match(w1, w2):             return sum(i == j for i, j in zip(w1, w2))          n = 0         while n < 6:             count = [collections.Counter(w[i] for w in wordlist) for i in xrange(6)]             guess = max(wordlist, key=lambda w: sum(count[i][c] for i, c in enumerate(w)))             n = master.guess(guess)             wordlist = [w for w in wordlist if match(w, guess) == n] ```  

https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-'substring'-problems
Here is a 10-line template that can solve most 'substring' problems
I will first give the solution then show you the magic template.  **The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss**.      string minWindow(string s, string t) {             vector<int> map(128,0);             for(auto c: t) map[c]++;             int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;             while(end<s.size()){                 if(map[s[end++]]-->0) counter--; //in t                 while(counter==0){ //valid                     if(end-begin<d)  d=end-(head=begin);                     if(map[s[begin++]]++==0) counter++;  //make it invalid                 }               }             return d==INT_MAX? \"\":s.substr(head, d);         }  **Here comes the template.**  For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below.        int findSubstring(string s){             vector<int> map(128,0);             int counter; // check whether the substring is valid             int begin=0, end=0; //two pointers, one point to tail and one  head             int d; //the length of substring              for() { /* initialize the hash map here */ }                  while(end<s.size()){                  if(map[s[end++]]-- ?){  /* modify counter here */ }                      while(/* counter condition */){                                             /* update d here if finding minimum*/                      //increase begin to make it invalid/valid again                                          if(map[s[begin++]]++ ?){ /*modify counter here*/ }                 }                      /* update d here if finding maximum*/             }             return d;       }  *One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.*   The code of solving **Longest Substring with At Most Two Distinct Characters** is below:      int lengthOfLongestSubstringTwoDistinct(string s) {             vector<int> map(128, 0);             int counter=0, begin=0, end=0, d=0;              while(end<s.size()){                 if(map[s[end++]]++==0) counter++;                 while(counter>2) if(map[s[begin++]]--==1) counter--;                 d=max(d, end-begin);             }             return d;         }  The code of solving **Longest Substring Without Repeating Characters** is below:  **Update 01.04.2016, thanks @weiyi3 for advise.**      int lengthOfLongestSubstring(string s) {             vector<int> map(128,0);             int counter=0, begin=0, end=0, d=0;              while(end<s.size()){                 if(map[s[end++]]++>0) counter++;                  while(counter>0) if(map[s[begin++]]-->1) counter--;                 d=max(d, end-begin); //while valid, update d             }             return d;         }      I think this post deserves some upvotes! : )

https://leetcode.com/problems/critical-connections-in-a-network/discuss/382638/DFS-detailed-explanation-O(orEor)-solution
DFS detailed explanation, O(|E|) solution
## **First thought**  Thiking for a little while, you will easily find out this theorem on a connected graph:  * **An edge is a critical connection, if and only if it is not in a cycle.**  So, if we know how to find cycles, and discard all edges in the cycles, then the remaining connections are a complete collection of critical connections.  ----  ## **How to find eges in cycles, and remove them**  We will use DFS algorithm to find cycles and decide whether or not an edge is in a cycle.  Define **rank** of a node: The depth of a node during a DFS. The starting node has a *rank* 0.  Only the nodes on the current DFS path have non-special *ranks*. In other words, only the nodes that we\\'ve started visiting, but haven\\'t finished visiting, have *ranks*. So `0 <= rank < n`.  (For coding purpose, if a node is not visited yet, it has a special rank `-2`; if we\\'ve fully completed the visit of a node, it has a special rank `n`.)  **How can \"rank\" help us with removing cycles?** Imagine you have a current path of length `k` during a DFS. The nodes on the path has increasing ranks from `0` to `k`and incrementing by `1`. Surprisingly, your next visit finds a node that has a rank of `p` where `0 <= p < k`. Why does it happen? Aha! You found a node that is on the current search path! That means, congratulations, you found a cycle!  But only the current level of search knows it finds a cycle. How does the upper level of search knows, if you backtrack? Let\\'s make use of the return value of DFS: **`dfs` function returns the minimum rank it finds.** During a step of search from node `u` to its neighbor `v`, **if `dfs(v)` returns something smaller than or equal to `rank(u)`**, then `u` knows its neighbor `v` helped it to find a cycle back to `u` or `u`\\'s ancestor. So `u` knows it should discard the edge `(u, v)` which is in a cycle.  After doing dfs on all nodes, all edges in cycles are discarded. So the remaining edges are critical connections.  ----  ## **Python code**  ``` import collections class Solution(object):     def criticalConnections(self, n, connections):         def makeGraph(connections):             graph = collections.defaultdict(list)             for conn in connections:                 graph[conn[0]].append(conn[1])                 graph[conn[1]].append(conn[0])             return graph          graph = makeGraph(connections)         connections = set(map(tuple, (map(sorted, connections))))         rank = [-2] * n          def dfs(node, depth):             if rank[node] >= 0:                 # visiting (0<=rank<n), or visited (rank=n)                 return rank[node]             rank[node] = depth             min_back_depth = n             for neighbor in graph[node]:                 if rank[neighbor] == depth - 1:                     continue  # don\\'t immmediately go back to parent. that\\'s why i didn\\'t choose -1 as the special value, in case depth==0.                 back_depth = dfs(neighbor, depth + 1)                 if back_depth <= depth:                     connections.discard(tuple(sorted((node, neighbor))))                 min_back_depth = min(min_back_depth, back_depth)             rank[node] = n  # this line is not necessary. see the \"brain teaser\" section below             return min_back_depth                      dfs(0, 0)  # since this is a connected graph, we don\\'t have to loop over all nodes.         return list(connections) ```  ----  ## **Complexity analysis** DFS time complexity is O(|E| + |V|), attempting to visit each edge at most twice. (the second attempt will immediately return.) As the graph is always a connected graph, |E| >= |V|.  So, time complexity = O(|E|).  Space complexity = O(graph) + O(rank) + O(connections) = 3 * O(|E| + |V|) = O(|E|).  ----  ## **FAQ: Are you reinventing Tarjan?** Honestly, I didn\\'t know Tarjan beforehand. The idea of using `rank` is inspired by [preordering](https://en.wikipedia.org/wiki/Depth-first_search#Vertex_orderings) which is a basic concept of DFS. Now I realize they are similar, but there are still major differences between them.  * This solution uses only one array `rank`. While Tarjan uses two arrays: `dfn` and `low`. * This solution\\'s `min_back_depth` is similar to Tarjan\\'s `low`, but `rank` is very different than `dfn`. `max(dfn)` is always n-1, while `max(rank)` could be smaller than n-1. * This solution construsts the result by removing non-critical edges **during** the dfs, while Tarjan constructs the result by collecting non-critical edges **after** the dfs. * In this solution, only nodes actively in the current search path have `0<=rank[node]<n`; while in Tarjan, nodes not actively in the current search path may still have `0<=dfn[node]<=low[node]<n`.  ----  ## **Brain teaser**  Thanks [@migfulcrum](https://leetcode.com/migfulcrum) for [pointing out](https://leetcode.com/discuss/comment/359567) that `rank[node] = n` is not necessary. He is totally right. I\\'ll leave this as a brain teaser for you: why is it not necessary? (Hint: after we\\'ve finished visiting a node, is it possible to have another search path attempting to visit this node again?)  ----  (If you like this post, don\\'t forget to vote up so more people will read it!)

https://leetcode.com/problems/consecutive-numbers-sum/discuss/129015/5-lines-C%2B%2B-solution-with-detailed-mathematical-explanation.
5 lines C++ solution with detailed mathematical explanation.
The thought process goes like this- Given a number `N`, we can *possibly* write it as a sum of 2 numbers, 3 numbers, 4 numbers and so on. Let\\'s assume the fist number in this series be `x`. Hence, we should have  `x + (x+1) + (x+2)+...+ k terms = N` `kx + k*(k-1)/2 = N` implies `kx  = N - k*(k-1)/2` So, we can calculate the RHS for every value of `k` and if it is a multiple of `k` then we can construct a sum of `N` using `k` terms starting from `x`. Now, the question arises, till what value of `k` should we loop for? That\\'s easy. In the worst case, RHS should be greater than 0. That is  ` N - k*(k-1)/2 > 0` which implies `k*(k-1) < 2N` which can be approximated to `k*k < 2N ==> k < sqrt(2N)` Hence the overall complexity of the algorithm is `O(sqrt(N))`  **PS**: OJ expects the answer to be 1 greater than the number of possible ways because it considers `N` as being written as `N` itself. It\\'s confusing since they ask for sum of consecutive integers which implies atleast 2 numbers. But to please OJ, we should start `count` from 1.  ``` class Solution { public:     int consecutiveNumbersSum(int N) {         int count = 1;         for( int k = 2; k < sqrt( 2 * N ); k++ ) {             if ( ( N - ( k * ( k - 1 )/2) ) % k == 0) count++;         }         return count;     } }; ```

https://leetcode.com/problems/consecutive-numbers-sum/discuss/128947/JavaC%2B%2BPython-Fastest-Count-Odd-Factors-O(logN)
[Java/C++/Python] Fastest, Count Odd Factors, O(logN)
## **Basic Math** `N = (x+1) + (x+2) + ... + (x+k)` `N = kx + k(k+1)/2` `N * 2 = k(2x + k + 1)`,where `x >= 0, k >= 1`  Either `k` or `2x + k + 1` is odd.  It means that, for each odd factor of `N`, we can find a consecutive numbers solution.  Now this problem is only about counting odd numbers! I believe you can find many solutions to do this. Like `O(sqrt(N))` solution used in all other post.  Here I shared my official solution. <br>  ## **Some Math about Counting Factors** If `N = 3^a * 5^b * 7*c * 11*d ....`, the number of factors that `N` has equals `N_factors = (a + 1) * (b + 1) * (c + 1) * (d + 1) .....` <br>  ## **Explanantion**: 1. Discard all factors 2 from `N`. 2. Check all odd number `i` if `N` is divided by `i`. 3. Calculate the `count` of factors `i` that `N` has. 4. Update `res *= count`. 5. If `N==1`, we have found all primes and just return res. Otherwise, `N` will be equal to `P` and we should do `res += count + 1` where `count = 1`. <br>  ## **Complexity:** To be more accurate, it\\'s `O(biggest prime factor)`. Because every time I find a odd factor, we do `N /= i`. This help reduce `N` faster.  Assume `P` is the biggest prime factor of a **odd** number `N` . If `N = 3^x * 5^y ...*  P`, Loop on `i` will stop at `P^0.5` If `N = 3^x * 5^y ...*  P^z`, Loop on `i` will stop at `P`. In the best case, `N = 3^x` and our solution is `O(log3N)` In the worst case, `N = P^2` and our solution is `O(P) = O(N^0.5)`  Though in my solution, we didn\\'t cache our process of finding odd factor. Moreover, if we prepare all prime between `[3\，10^4.5]`. it will be super faster because there are only 3400 primes in this range. This complexity will be `O(P/logP)` with `P < sqrt(N)` <br>   **Java** ```java     public int consecutiveNumbersSum(int N) {         int res = 1, count;         while (N % 2 == 0) N /= 2;         for (int i = 3; i * i <= N; i += 2) {             count = 0;             while (N % i == 0) {                 N /= i;                 count++;             }             res *= count + 1;         }         return N == 1 ? res : res * 2;     } ``` **Short C++/Java:** ```cpp         int res = 1, count;         while (N % 2 == 0) N /= 2;         for (int i = 3; i * i <= N; res *= count + 1, i += 2)             for (count = 0; N % i == 0; N /= i, count++);         return N == 1 ? res : res * 2; ``` **Python** ```py     def consecutiveNumbersSum(self, N):         res = 1         i = 3         while N % 2 == 0:             N /= 2         while i * i <= N:             count = 0             while N % i == 0:                 N /= i                 count += 1             res *= count + 1             i += 2         return res if N == 1 else res * 2 ```  

https://leetcode.com/problems/time-based-key-value-store/discuss/226664/C%2B%2B-3-lines-hash-map-%2B-map
C++ 3 lines, hash map + map
We use hash map to lookup ordered ```{timestamp, value}``` pairs by key in O(1). Then, we use binary search to find the value with a timestamp less or equal than the requested one. ``` unordered_map<string, map<int, string>> m; void set(string key, string value, int timestamp) {   m[key].insert({ timestamp, value }); } string get(string key, int timestamp) {   auto it = m[key].upper_bound(timestamp);   return it == m[key].begin() ? \"\" : prev(it)->second; } ``` Since our timestamps are only increasing, we can use a vector instead of a map, though it\\'s not as concise. ``` unordered_map<string, vector<pair<int, string>>> m; void set(string key, string value, int timestamp) {   m[key].push_back({ timestamp, value }); } string get(string key, int timestamp) {   auto it = upper_bound(begin(m[key]), end(m[key]), pair<int, string>(timestamp, \"\"), [](     const pair<int, string>& a, const pair<int, string>& b) { return a.first < b.first; });   return it == m[key].begin() ? \"\" : prev(it)->second; } ``` # Complexity analysis Assuming ```n``` is the number of set operations, and ```m``` is the number of get operations: - Time Complexity:      - Set: ```O(1)``` single operation, and total ```O(n)```. Note: assuing timestamps are only increasing. If not, it\\'s ```O(n log n)```.     - Get: ```O(log n)``` for a single operation, and total ```O(m log n)```. - Space Complexity: ```O(n)``` (assuming every ```{ timestamp, value }``` is unique).

https://leetcode.com/problems/burst-balloons/discuss/76228/Share-some-analysis-and-explanations
Share some analysis and explanations
**See [here for a better view](http://algobox.org/burst-balloons/)**  **Be Naive First**  When I first get this problem, it is far from dynamic programming to me. I started with the most naive idea the backtracking.  We have n balloons to burst, which mean we have n steps in the game. In the i th step we have n-i balloons to burst, i = 0~n-1. Therefore we are looking at an algorithm of O(n!). Well, it is slow, probably works for n < 12 only.  Of course this is not the point to implement it. We need to identify the redundant works we did in it and try to optimize.  Well, we can find that for any balloons left the maxCoins does not depends on the balloons already bursted. This indicate that we can use memorization (top down) or dynamic programming (bottom up) for all the cases from small numbers of balloon until n balloons. How many cases are there?  For k balloons there are C(n, k) cases and for each case it need to scan the k balloons to compare. The sum is quite big still. It is better than O(n!) but worse than O(2^n).   **Better idea**  We then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis.  Well,  the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future.  Then another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore instead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst.   Why is that? Because only the first and last balloons we are sure of their adjacent balloons before hand!  For the first we have `nums[i-1]*nums[i]*nums[i+1]` for the last we have `nums[-1]*nums[i]*nums[n]`.   OK. Think about n balloons if i is the last one to burst, what now?  We can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp.  **Final**  Here comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won't give any coins. The algorithm runs in O(n^3) which can be easily seen from the 3 loops in dp solution.  **Java D&C with Memoization**      public int maxCoins(int[] iNums) {         int[] nums = new int[iNums.length + 2];         int n = 1;         for (int x : iNums) if (x > 0) nums[n++] = x;         nums[0] = nums[n++] = 1;           int[][] memo = new int[n][n];         return burst(memo, nums, 0, n - 1);     }      public int burst(int[][] memo, int[] nums, int left, int right) {         if (left + 1 == right) return 0;         if (memo[left][right] > 0) return memo[left][right];         int ans = 0;         for (int i = left + 1; i < right; ++i)             ans = Math.max(ans, nums[left] * nums[i] * nums[right]              + burst(memo, nums, left, i) + burst(memo, nums, i, right));         memo[left][right] = ans;         return ans;     }     // 12 ms  **Java DP**      public int maxCoins(int[] iNums) {         int[] nums = new int[iNums.length + 2];         int n = 1;         for (int x : iNums) if (x > 0) nums[n++] = x;         nums[0] = nums[n++] = 1;           int[][] dp = new int[n][n];         for (int k = 2; k < n; ++k)             for (int left = 0; left < n - k; ++left) {                 int right = left + k;                 for (int i = left + 1; i < right; ++i)                     dp[left][right] = Math.max(dp[left][right],                      nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]);             }          return dp[0][n - 1];     }     // 17 ms  **C++ DP**      int maxCoinsDP(vector<int> &iNums) {         int nums[iNums.size() + 2];         int n = 1;         for (int x : iNums) if (x > 0) nums[n++] = x;         nums[0] = nums[n++] = 1;           int dp[n][n] = {};         for (int k = 2; k < n; ++k) {             for (int left = 0; left < n - k; ++left)                 int right = left + k;                 for (int i = left + 1; i < right; ++i)                     dp[left][right] = max(dp[left][right],                          nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]);             }          return dp[0][n - 1];     }     // 16 ms  **Python DP**      def maxCoins(self, iNums):         nums = [1] + [i for i in iNums if i > 0] + [1]         n = len(nums)         dp = [[0]*n for _ in xrange(n)]          for k in xrange(2, n):             for left in xrange(0, n - k):                 right = left + k                 for i in xrange(left + 1,right):                     dp[left][right] = max(dp[left][right],                            nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])         return dp[0][n - 1]      # 528ms

https://leetcode.com/problems/longest-consecutive-sequence/discuss/41055/My-really-simple-Java-O(n)-solution-Accepted
My really simple Java O(n) solution - Accepted
We will use HashMap. The key thing is to keep track of the sequence length and store that in the boundary points of the sequence. For example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5.  Whenever a new element **n** is inserted into the map, do two things:   1. See if **n - 1** and **n + 1** exist in the map, and if so, it means there is an existing sequence next to **n**. Variables **left** and **right** will be the length of those two sequences, while **0** means there is no sequence and **n** will be the boundary point later. Store **(left + right + 1)** as the associated value to key **n** into the map.  2. Use **left** and **right** to locate the other end of the sequences to the left and right of **n** respectively, and replace the value with the new length.   Everything inside the **for** loop is O(1) so the total time is O(n). Please comment if you see something wrong. Thanks.      public int longestConsecutive(int[] num) {         int res = 0;         HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();         for (int n : num) {             if (!map.containsKey(n)) {                 int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;                 int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;                 // sum: length of the sequence n is in                 int sum = left + right + 1;                 map.put(n, sum);                                  // keep track of the max length                  res = Math.max(res, sum);                                  // extend the length to the boundary(s)                 // of the sequence                 // will do nothing if n has no neighbors                 map.put(n - left, sum);                 map.put(n + right, sum);             }             else {                 // duplicates                 continue;             }         }         return res;     }

https://leetcode.com/problems/longest-consecutive-sequence/discuss/41057/Simple-O(n)-with-Explanation-Just-walk-each-streak
Simple O(n) with Explanation - Just walk each streak
First turn the input into a *set* of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number.  Then go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, ... and stop at the first number y *not* in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ, one of the fastest Python submissions.      def longestConsecutive(self, nums):         nums = set(nums)         best = 0         for x in nums:             if x - 1 not in nums:                 y = x + 1                 while y in nums:                     y += 1                 best = max(best, y - x)         return best

https://leetcode.com/problems/task-scheduler/discuss/104500/Java-O(n)-time-O(1)-space-1-pass-no-sorting-solution-with-detailed-explanation
Java O(n) time O(1) space 1 pass, no sorting solution with detailed explanation
The key is to find out how many idles do we need. Let's first look at how to arrange them. it's not hard to figure out that we can do a \"greedy arrangement\": always arrange task with most frequency first. E.g. we have following tasks : 3 A, 2 B, 1 C. and we have n = 2. According to what we have above, we should first arrange A, and then B and C. Imagine there are \"slots\" and we need to arrange tasks by putting them into \"slots\". Then A should be put into slot 0, 3, 6 since we need to have at least n = 2 other tasks between two A. After A put into slots, it looks like this:  A ? ? A ? ? A \"?\" is \"empty\" slots.  Now we can use the same way to arrange B and C. The finished schedule should look like this:  A B C A B # A \"#\" is idle  Now we have a way to arrange tasks. But the problem only asks for number of CPU intervals, so we don't need actually arrange them. Instead we only need to get the total idles we need and the answer to problem is just number of idles + number of tasks. Same example: 3 A, 2 B, 1 C, n = 2. After arranging A, we have: A ? ? A ? ? A We can see that A separated slots into (count(A) - 1) = 2 parts, each part has length n. With the fact that A is the task with most frequency, it should need more idles than any other tasks. **In this case if we can get how many idles we need to arrange A, we will also get number of idles needed to arrange all tasks.** Calculating this is not hard, we first get number of parts separated by A: partCount = count(A) - 1; then we can know number of empty slots: emptySlots = partCount * n; we can also get how many tasks we have to put into those slots: availableTasks = tasks.length - count(A). Now if we have emptySlots > availableTasks which means we have not enough tasks available to fill all empty slots, we must fill them with idles. Thus we have **idles = max(0, emptySlots - availableTasks);** Almost done. One special case: what if there are more than one task with most frequency? OK, let's look at another example: 3 A 3 B 2 C 1 D,  n = 3 Similarly we arrange A first: A ? ? ? A ? ? ? A Now it's time to arrange B, we find that we have to arrange B like this: A B ? ? A B ? ? A B we need to put every B right after each A. Let's look at this in another way, think of sequence \"A B\" as a special task \"X\", then we got: X ? ? X ? ? X Comparing to what we have after arranging A: A ? ? ? A ? ? ? A The only changes are length of each parts (from 3 to 2) and available tasks. By this we can get more general equations: **partCount = count(A) - 1 emptySlots = partCount * (n - (count of tasks with most frequency - 1)) availableTasks = tasks.length - count(A) * count of tasks with most frenquency idles = max(0, emptySlots - availableTasks) result = tasks.length + idles**  What if we have more than n tasks with most frequency and we got emptySlot negative? Like 3A, 3B, 3C, 3D, 3E, n = 2. In this case seems like we can't put all B C S inside slots since we only have n = 2. Well partCount is actually the \"minimum\" length of each part required for arranging A. You can always make the length of part longer. E.g. 3A, 3B, 3C, 3D, 2E, n = 2. You can always first arrange A, B, C, D as: A B C D | A B C D | A B C D in this case you have already met the \"minimum\" length requirement for each part (n = 2), you can always put more tasks in each part if you like: e.g. A B C D E | A B C D E | A B C D  emptySlots < 0 means you have already got enough tasks to fill in each part to make arranged tasks valid. But as I said you can always put more tasks in each part once you met the \"minimum\" requirement.  To get count(A) and count of tasks with most frequency, we need to go through inputs and calculate counts for each distinct char. This is O(n) time and O(26) space since we only handle upper case letters. All other operations are O(1) time O(1) space which give us total time complexity of O(n) and space O(1) ``` public class Solution {     public int leastInterval(char[] tasks, int n) {         int[] counter = new int[26];         int max = 0;         int maxCount = 0;         for(char task : tasks) {             counter[task - 'A']++;             if(max == counter[task - 'A']) {                 maxCount++;             }             else if(max < counter[task - 'A']) {                 max = counter[task - 'A'];                 maxCount = 1;             }         }                  int partCount = max - 1;         int partLength = n - (maxCount - 1);         int emptySlots = partCount * partLength;         int availableTasks = tasks.length - max * maxCount;         int idles = Math.max(0, emptySlots - availableTasks);                  return tasks.length + idles;     } } ```

https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack
My O(n) solution using a stack
```    class Solution {     public:         int longestValidParentheses(string s) {             int n = s.length(), longest = 0;             stack<int> st;             for (int i = 0; i < n; i++) {                 if (s[i] == '(') st.push(i);                 else {                     if (!st.empty()) {                         if (s[st.top()] == '(') st.pop();                         else st.push(i);                     }                     else st.push(i);                 }             }             if (st.empty()) longest = n;             else {                 int a = n, b = 0;                 while (!st.empty()) {                     b = st.top(); st.pop();                     longest = max(longest, a-b-1);                     a = b;                 }                 longest = max(longest, a);             }             return longest;         }     };```  The workflow of the solution is as below.   1. Scan the string from beginning to end.    2. If current character is '(',     push its index to the stack. If current character is ')' and the     character at the index of the top of stack is '(', we just find a     matching pair so pop from the stack. Otherwise, we push the index of     ')' to the stack.  3. After the scan is done, the stack will only     contain the indices of characters which cannot be matched. Then     let's use the opposite side -  substring between adjacent indices     should be valid parentheses.   4. If the stack is empty, the whole input     string is valid. Otherwise, we can scan the stack to get longest     valid substring as described in step 3.

https://leetcode.com/problems/most-common-word/discuss/123854/C%2B%2BJavaPython-Easy-Solution-with-Explanation
[C++/Java/Python] Easy Solution with Explanation
The description doesn\\'t clearify the case like \"word,word,word\". And it doesn\\'t have this kind of corner cases at first. The test cases and OJ may not be perfect on this problem.  Anyway I didn\\'t bother thinking this issue. In my opinion, the problem demands to extract words with only letters. All I did is just extract words with only letters.  4 steps: 1. remove all punctuations 2. change to lowercase 3. words count for each word not in banned set 4. return the most common word  **C++:** ```     string mostCommonWord(string p, vector<string>& banned) {         unordered_set<string> ban(banned.begin(), banned.end());         unordered_map<string, int> count;         for (auto & c: p) c = isalpha(c) ? tolower(c) : \\' \\';         istringstream iss(p);         string w;         pair<string, int> res (\"\", 0);         while (iss >> w)             if (ban.find(w) == ban.end() && ++count[w] > res.second)                 res = make_pair(w, count[w]);         return res.first;     } ``` **Java:** ```     public String mostCommonWord(String p, String[] banned) {         Set<String> ban = new HashSet<>(Arrays.asList(banned));         Map<String, Integer> count = new HashMap<>();         String[] words = p.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\");         for (String w : words) if (!ban.contains(w)) count.put(w, count.getOrDefault(w, 0) + 1);         return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();     } ```  **Python:** Thanks to @sirxudi I change one line from `words = re.sub(r\\'[^a-zA-Z]\\', \\' \\', p).lower().split()` to  `words = re.findall(r\\'\\\\w+\\', p.lower()) ` ```     def mostCommonWord(self, p, banned):         ban = set(banned)         words = re.findall(r\\'\\\\w+\\', p.lower())         return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0] ```

https://leetcode.com/problems/find-median-from-data-stream/discuss/74062/Short-simple-JavaC%2B%2BPython-O(log-n)-%2B-O(1)
Short simple Java/C++/Python, O(log n) + O(1)
I keep two heaps (or priority queues):  - Max-heap `small` has the smaller half of the numbers. - Min-heap `large` has the larger half of the numbers.  This gives me direct access to the one or two middle values (they're the tops of the heaps), so getting the median takes O(1) time. And adding a number takes O(log n) time.  Supporting both min- and max-heap is more or less cumbersome, depending on the language, so I simply negate the numbers in the heap in which I want the reverse of the default order. To prevent this from causing a bug with -2<sup>31</sup> (which negated is itself, when using 32-bit ints), I use integer types larger than 32 bits.  Using larger integer types also prevents an overflow error when taking the mean of the two middle numbers. I think almost all solutions posted previously have that bug.  **Update:** These are pretty short already, but by now I wrote [even shorter ones](https://leetcode.com/discuss/64910/very-short-o-log-n-o-1).  ---  **Java**      class MedianFinder {              private Queue<Long> small = new PriorityQueue(),                             large = new PriorityQueue();              public void addNum(int num) {             large.add((long) num);             small.add(-large.poll());             if (large.size() < small.size())                 large.add(-small.poll());         }              public double findMedian() {             return large.size() > small.size()                    ? large.peek()                    : (large.peek() - small.peek()) / 2.0;         }     };  Props to [larrywang2014's solution](https://leetcode.com/discuss/64842/32ms-easy-to-understand-java-solution) for making me aware that I can use Queue in the declaration instead of PriorityQueue (that's all I got from him, though (just saying because I just saw he changed his previously longer addNum and it's now equivalent to mine)).  ---  **C++**      class MedianFinder {         priority_queue<long> small, large;     public:              void addNum(int num) {             small.push(num);             large.push(-small.top());             small.pop();             if (small.size() < large.size()) {                 small.push(-large.top());                 large.pop();             }         }              double findMedian() {             return small.size() > large.size()                    ? small.top()                    : (small.top() - large.top()) / 2.0;         }     };  Big thanks to jianchao.li.fighter for telling me that C++'s priority_queue is a max-queue (see comments below).  ---  **Python**      from heapq import *          class MedianFinder:              def __init__(self):             self.heaps = [], []              def addNum(self, num):             small, large = self.heaps             heappush(small, -heappushpop(large, num))             if len(large) < len(small):                 heappush(large, -heappop(small))              def findMedian(self):             small, large = self.heaps             if len(large) > len(small):                 return float(large[0])             return (large[0] - small[0]) / 2.0

https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74253/Easy-to-understand-Java-Solution
Easy to understand Java Solution
The idea is simple: print the tree in pre-order traversal and use \"X\" to denote null node and split node with \",\". We can use a StringBuilder for building the string on the fly. For deserializing, we use a Queue to store the pre-order traversal and since we have \"X\" as null node, we know exactly how to where to end building subtress.      public class Codec {         private static final String spliter = \",\";         private static final String NN = \"X\";              // Encodes a tree to a single string.         public String serialize(TreeNode root) {             StringBuilder sb = new StringBuilder();             buildString(root, sb);             return sb.toString();         }              private void buildString(TreeNode node, StringBuilder sb) {             if (node == null) {                 sb.append(NN).append(spliter);             } else {                 sb.append(node.val).append(spliter);                 buildString(node.left, sb);                 buildString(node.right,sb);             }         }         // Decodes your encoded data to tree.         public TreeNode deserialize(String data) {             Deque<String> nodes = new LinkedList<>();             nodes.addAll(Arrays.asList(data.split(spliter)));             return buildTree(nodes);         }                  private TreeNode buildTree(Deque<String> nodes) {             String val = nodes.remove();             if (val.equals(NN)) return null;             else {                 TreeNode node = new TreeNode(Integer.valueOf(val));                 node.left = buildTree(nodes);                 node.right = buildTree(nodes);                 return node;             }         }     }

https://leetcode.com/problems/reaching-points/discuss/114856/JavaC%2B%2BPython-Modulo-from-the-End
[Java/C++/Python] Modulo from the End
**Basic idea:** If we start from ```sx,sy```, it will be hard to find ```tx, ty```. If we start from ```tx,ty```, we can find only one path to go back to ```sx, sy```. I cut down one by one at first and I got TLE. So I came up with remainder.  **First line:** if 2 target points are still bigger than 2 starting point, we reduce target points. **Second line:** check if we reduce target points to (x, y+kx) or (x+ky, y)  **Time complexity** I will say ```O(logN)``` where ```N = max(tx,ty)```.  **C++:** ```cpp     bool reachingPoints(int sx, int sy, int tx, int ty) {         while (sx < tx && sy < ty)             if (tx < ty) ty %= tx;             else tx %= ty;         return sx == tx && sy <= ty && (ty - sy) % sx == 0 ||                sy == ty && sx <= tx && (tx - sx) % sy == 0;     } ``` **Java:** ```java     public boolean reachingPoints(int sx, int sy, int tx, int ty) {         while (sx < tx && sy < ty)             if (tx < ty) ty %= tx;             else tx %= ty;         return sx == tx && sy <= ty && (ty - sy) % sx == 0 ||                sy == ty && sx <= tx && (tx - sx) % sy == 0;     } ``` **Python:** ```py     def reachingPoints(self, sx, sy, tx, ty):         while sx < tx and sy < ty:             tx, ty = tx % ty, ty % tx         return sx == tx and sy <= ty and (ty - sy) % sx == 0 or \\\\                sy == ty and sx <= tx and (tx - sx) % sy == 0 ```

https://leetcode.com/problems/number-of-music-playlists/discuss/180338/DP-solution-that-is-Easy-to-understand
DP solution that is Easy to understand
dp[i][j] denotes the solution of  i songs with  j different songs. So the final answer should be dp[L][N]  Think one step before the last one, there are only cases for the answer of dp[i][j] case 1 (the last added one is new song): listen i - 1 songs with j - 1 different songs, then the last one is definitely new song with the choices of N - (j - 1).  Case 2 (the last added one is old song): listen i - 1 songs with j different songs, then the last one is definitely old song with the choices of j if without the constraint of K, the status equation will be dp[i][j] = dp[i-1][j-1] * (N - (j-1)) + dp[i-1][j] * j  If with the constaint of K, there are also two cases Case 1: no changes since the last added one is new song. Hence, there is no conflict Case 2: now we don\\'t have choices of j for the last added old song. It should be updated j - k because k songs can\\'t be chosed from j - 1 to j - k. However, if  j <= K,  this case will be 0 because only after choosing K different other songs, old song can be chosen.  if (j > k) dp[i][j] = dp[i-1][j-1] * (N- (j-1)) + dp[i-1][j] * (j-k) else dp[i][j] = dp[i-1][j-1] * (N- (j-1))  ``` class Solution {     public int numMusicPlaylists(int N, int L, int K) {         int mod = (int)Math.pow(10, 9) + 7;         long[][] dp = new long[L+1][N+1];         dp[0][0] = 1;         for (int i = 1; i <= L; i++){             for (int j = 1; j <= N; j++){                 dp[i][j] = (dp[i-1][j-1] * (N - (j-1)))%mod;                  if (j > K){                     dp[i][j] = (dp[i][j] + (dp[i-1][j] * (j-K))%mod)%mod;                 }             }         }         return (int)dp[L][N];     } } ```
